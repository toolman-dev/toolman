// Copyright 2020 the Toolman project authors. All rights reserved.
// Use of this source code is governed by a MIT license that can be
// found in the LICENSE file.

#ifndef TOOLMAN_GENERATOR_H_
#define TOOLMAN_GENERATOR_H_

#include <memory>

#include "src/custom_type.h"
#include "src/document.h"

#define INDENT_1 "    "
#define INDENT INDENT_1
#define INDENT_2 INDENT_1 INDENT_1
#define INDENT_3 INDENT_2 INDENT_1
#define INDENT_4 INDENT_3 INDENT_1

#define NL "\n"
#define NL1 NL
#define NL2 NL1 NL1
#define NL3 NL2 NL1
#define NL4 NL3 NL1

namespace toolman {

class Generator {
 public:
  virtual void before_generate_document(std::ostream& ostream,
                                        const Document* document) const {}
  virtual void after_generate_document(std::ostream& ostream,
                                       const Document* document) const {}
  virtual void before_generate_struct(std::ostream& ostream,
                                      const Document* document) const {}
  virtual void after_generate_struct(std::ostream& ostream,
                                     const Document* document) const {}
  virtual void before_generate_enum(std::ostream& ostream,
                                    const Document* document) const {}
  virtual void after_generate_enum(std::ostream& ostream,
                                   const Document* document) const {}

  [[nodiscard]] virtual std::string single_line_comment(
      std::string code) const = 0;

  virtual void generate_struct(
      std::ostream& ostream,
      const std::shared_ptr<StructType>& struct_type) const = 0;
  virtual void generate_enum(
      std::ostream& ostream,
      const std::shared_ptr<EnumType>& enum_type) const = 0;

  void generate(std::ostream& ostream,
                const std::unique_ptr<Document>& document) const {
    ostream << single_line_comment(
                   "Generated by the toolman compiler. DO NOT EDIT!")
            << NL
            << single_line_comment("source: " +
                                   document->get_file()->filename().string())
            << NL << NL;
    before_generate_document(ostream, document.get());
    before_generate_struct(ostream, document.get());
    for (const auto& struct_type : document->get_struct_types()) {
      generate_struct(ostream, struct_type);
    }

    after_generate_struct(ostream, document.get());
    before_generate_enum(ostream, document.get());
    for (const auto& enum_type : document->get_enum_types()) {
      generate_enum(ostream, enum_type);
    }
    after_generate_enum(ostream, document.get());
    after_generate_document(ostream, document.get());
    ostream << std::flush;
  }
};

/**
 * Transforms a camel case string to an equivalent one separated by underscores
 * e.g. aMultiWord -> a_multi_word
 *      someName   -> some_name
 *      CamelCase  -> camel_case
 *      name       -> name
 *      Name       -> name
 */
std::string underscore(std::string in) {
  in[0] = tolower(in[0]);
  for (size_t i = 1; i < in.size(); ++i) {
    if (isupper(in[i])) {
      in[i] = tolower(in[i]);
      in.insert(i, "_");
    }
  }
  return in;
}

/**
 * Transforms a string with words separated by underscores to a camel case
 * equivalent
 * e.g.
 * a_multi_word -> aMultiWord
 * some_name    -> someName
 * name         -> name
 */
std::string camelcase(const std::string& in) {
  std::ostringstream out;
  bool underscore = false;

  for (char c : in) {
    if (c == '_') {
      underscore = true;
      continue;
    }
    if (underscore) {
      out << (char)toupper(c);
      underscore = false;
      continue;
    }
    out << c;
  }

  return out.str();
}

/**
 * Capitalization helpers
 */
std::string capitalize(std::string in) {
  in[0] = toupper(in[0]);
  return in;
}

std::string decapitalize(std::string in) {
  in[0] = tolower(in[0]);
  return in;
}

}  // namespace toolman

#endif  // TOOLMAN_GENERATOR_H_
