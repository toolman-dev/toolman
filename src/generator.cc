// Copyright 2020 the Toolman project authors. All rights reserved.
// Use of this source code is governed by a MIT license that can be
// found in the LICENSE file.

#include "src/generator.h"

#include "src/document.h"
#include "src/golang_generator.h"
#include "src/java_generator.h"
#include "src/typescript_generator.h"

namespace toolman::generator {

TargetLanguage target_language_from_string(
    std::string target) {
  std::transform(target.begin(), target.end(), target.begin(),
                 [](unsigned char c) { return std::tolower(c); });
  if (target == "java") {
    return TargetLanguage::JAVA;
  } else if (target == "go" || target == "golang") {
    return TargetLanguage::GOLANG;
  } else if (target == "ts" || target == "typescript") {
    return TargetLanguage::TYPESCRIPT;
  }
  return TargetLanguage::JAVA;
}

void Generator::generate(std::ostream& ostream,
                         const std::unique_ptr<Document>& document) {
  ostream << single_line_comment(
                 "Generated by the toolman compiler. DO NOT EDIT!")
          << NL
          << single_line_comment("source: " +
                                 document->get_source()->filename().string())
          << NL << NL;
  before_generate_document(ostream, document.get());
  before_generate_struct(ostream, document.get());
  for (const auto& struct_type : document->get_struct_types()) {
    generate_struct(ostream, struct_type);
  }

  after_generate_struct(ostream, document.get());
  before_generate_enum(ostream, document.get());
  for (const auto& enum_type : document->get_enum_types()) {
    generate_enum(ostream, enum_type);
  }
  after_generate_enum(ostream, document.get());
  after_generate_document(ostream, document.get());
  ostream << std::flush;
}

void generate(std::unique_ptr<Document> document, TargetLanguage targetLanguage,
              std::ostream& ostream) {
  std::unique_ptr<Generator> generator;
  switch (targetLanguage) {
    case TargetLanguage::GOLANG:
      generator = std::make_unique<GolangGenerator>();
      break;
    case TargetLanguage::TYPESCRIPT:
      generator = std::make_unique<TypescriptGenerator>();
      break;
    case TargetLanguage::JAVA:
      generator = std::make_unique<JavaGenerator>();
      break;
  }
  generator->generate(ostream, document);
}

std::string underscore(std::string in) {
  in[0] = tolower(in[0]);
  for (size_t i = 1; i < in.size(); ++i) {
    if (isupper(in[i])) {
      in[i] = tolower(in[i]);
      in.insert(i, "_");
    }
  }
  return in;
}

std::string camelcase(const std::string& in) {
  std::ostringstream out;
  bool underscore = false;

  for (char c : in) {
    if (c == '_') {
      underscore = true;
      continue;
    }
    if (underscore) {
      out << (char)toupper(c);
      underscore = false;
      continue;
    }
    out << c;
  }

  return out.str();
}
std::string capitalize(std::string in) {
  in[0] = toupper(in[0]);
  return in;
}

std::string decapitalize(std::string in) {
  in[0] = tolower(in[0]);
  return in;
}
}  // namespace toolman::generator
